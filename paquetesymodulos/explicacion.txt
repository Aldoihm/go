PAQUETE: es una carpeta con archivos a dentro para proporcionar una funcionalidad en específico
Dentro del paquete no se necesita que esté adentro el archivo main.go, ya que este archivo usa el paquete, por lo tanto nunca debe estar adentro
Notas:
    -Todos los archivos que están adentro del paquete(carpeta) debe contener la palabra package nombre_paquete (osea de la carpeta)
    -El nombre del paquete debe ser exactamente igual al nombre de la carpeta
    Ejemplo:

Carpeta: slices
    archivo: filter.go
        inicio del archivo: package slices (fijarse que el nombre del paquete es igual al nombre de la carpeta que contiene el paquete)
    archivo: includes.go
        inicio del archivo: package slices
    archivo: slices.go
        inicio del archivo: package slices

VARIABLES Y FUNCIONES:
Todas las funciones y variables que en su nombre(identificador) empiecen con letras MINÚSCULAS:
    -Solo se podran usar dentro del mismo paquete
    -Ejemplos: 
        const pkgName = "slices"
        func log (msg string){}
Todas las funciones y variables que en su nombre(identificador) empiecen con letras MAYÚSCULAS:
    -Se puedem usar fuera del paquete (osea los archivos main.go que importen dichos paquetes)
    -Ejemplo:
        func Includes[T comparable](list []T, value T) bool{retur true}
        func Filter(){}

NOMBRE DEL PAQUETE: 
No puede ser cualquier nombre, el nombre del paquete debe de especificar que es lo que hace el paquete.
No puede ser redundante en el nombre ejemplo:
    Forma incorrenta: slices.SlicesFilter()
    Forma correcta: slices.Filter()

MODULO: Para crear un modulo, se debe subir el paquete recien creado a un repositorio remoto (osea github). Ya que go trabaja con github
REGLA IMPORTANTE: para cada paquete, se debe tener su propio git init, ya que NO SE PUEDE TENER VARIOS PAQUETES EN UN SOLO GIT INIT.
                tampoco NO SE PUEDE TENER EN UN REPOSITORIO REMOTO VARIOS PAQUETES
                por lo tanto UN REPOSITORIO REMOTO = UN SOLO PAQUETE.
Ejemplo
carpeta raiz: modulo
        carpeta del paquete: slices
                archivos dentro del paquete:filter.go
                                            includes.go
                                            slices.go
        archivo dentro de carpeta raiz: main.go
        Se ejecuta en este nivel: git init
        Se crea el repositorio en github y sejecuntan las demás instrucciones para subir el repositorio...
        git branch -M main (por si se llama master la rama)
        git remote add origin git@github:..../modulo.git
        git push -u origin main

repositorio de github
Se crear el repositorio con el mismo nombre de la carpeta raiz:modulo

--Aqui termina el ejemplo

Para importar el modulo recien creado es necesario ejecutar las siguientes instrucciones al mismo nivel donde se encuentra el directorio main.go
1.- go mod init main: main es el nombre del modulo 
2.- se crear el archivo go.mod: adentro viene el directorio del modulo importado y la version de go usado
3.- en el archivo main.go importamos  en import y la direccion url del paquete + el nombre del paquete ejemplo:
    import "github.com/Aldoihm/module-example/slices"
4.- se ejecuta go mod tidy: con esta instrucción se importa el paquete de tercero en este caso goland.org/x/exp/constraints
5.- se crea el archivo go.sum, donde se especifica todo lo que se ha importado
6.- ya se puede ejecutar el programa

resumen:
1.- go mod init main
2.- go mod tidy

NOTA IMPORTANTE: Si quieres descargar más paquetes, puedes volver a ejecutar: go mod tidy para descargar los nuevos paquetes

Debo practicar.

go list -m all: Comando para mostrar la lista de modulos que está usando nuestro programa junto con su version
go mod graph : Comando para mostrar que modulos están importando los otros módulos.
Versionamiento Semantico:
V1.0.0 --> Versión que está en desarrollo y que por lo tanto no se debería usar
V1.0.1 --> Versión donde se encuentran y corrigen bugs, pero que no afecta al usuario final(version patch)
v1.1.0 --> Versión donde se realiza una nueva actualización, pero que no rompe compatibilidad con la versión anterior (nuevos modulos)(versión menor)
v1.1.1 --> Versión donde se encuentra y corrige bugs
v2.0.0 --> Versión que rompe compatibilidad con la versión anterior y que por lo tanto deberían actualizar(versión mayor)
v2.4.10-pre --> Versión de prelanzamiento (no es la ultima versión oficial)

Comando para ver todas las versiones disponibles de un paquete:
go list -m -versions nombre_paquete_a_consultar
go list -m -versions rsc.io/quote

cuales son los comandos para ver los paquetes que se importan de manera indirecta?
primero buscamos la directorio donde se instala go
1.- go env GOPATH
2.- Entramos a la dirección que nos arroja: cd /Users/aldo/go
3.- vamos a entrar a la siguiente direción: cd pkg/mod
4.- ll: para ver que ahí se encuentran todos los paquetes que se importan y su vez adentro las versiones.
5.- en mi caso queria ver los paquetes que importa el paquete rsc.io/quote@v1.5.2
6.- cd rsc.io/quote@v1.5.2
7.- ll: para verificar que se encuentra su archivo go.mod
8.- para ver el archivo uso cat go.mod. y listo. Veo la palabra require y aparecen los paquetes que el importa

Actualización de versiones menores
Para actualizar el paquete a la últimva versión
go get nombre_paquete: go get golang.org/x/text
Para actualizar a una versión en específico
go get nombre_paquete@vmayor.vmenor.vpatch : go get rsc.io/sampler@v1.3.1 

Actualización de versiones mayores
Antes de actualizar, ver los cambios de las funciones de la nueva version mayor a la anterior version mayor que tenemos instalado
con la finalidad de dar un uso correcto a nuestra implementación
1.- En el archivo main indicamos que importamos el nuevo paquete junto con la version y un alias. ejemplo
    import (
        "rsc.io/quote" -->version anterior
        quoteV3 "rsc.io/quote/v3" --> (quoteV3 es el alias) version nueva
        (se usa el alias porque el paquete rsc.io/quote, se repite y es necesario el alias para no crear confusion en go)
    )
    1.1.- Implementamos las nuevas funciones del paquete recien importado.
2.-go mod tidy. --> para que importe la nueva version
3.-Para ver las versiones del nuevo paquete importado:
    go list -m -versions rsc.io/quote/v3

Eliminar versiones anteriores que ya no usamos
1.-Quitamos en import la versión anterior y el alias de la nueva versión porque ya no será necesario usar el alias
    import(
        "rsc.io/quote/v3" --> se deja solo la nueva versión y eliminamos el alias
    )
    1.1.- eliminamos las funciones usadas del paquete anterior y renombramos las nuevas funciones sin usar el alias ejemplo
    1.2.- de usar quoteV3.HelloV3() --> pasa a quote.HelloV3() --> nota que ya se deja de usar el alias y solo se usa el nombre del paquete
2.-go mod tidy --> también elimina las versiones que ya no usamos
3.-para comprobar la nueva version y la version anterior que ya no esté usamos go list -m all